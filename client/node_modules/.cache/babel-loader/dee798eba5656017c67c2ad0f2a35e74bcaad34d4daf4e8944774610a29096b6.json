{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nconst VELOCITY_THRESHOLD = 0.5; // Minimum velocity to trigger swipe\nconst DISTANCE_THRESHOLD = 50; // Minimum distance to trigger swipe\nconst TIME_THRESHOLD = 300; // Maximum time for a swipe gesture\n\nexport const useSwipeGesture = ({\n  onSwipeLeft,\n  onSwipeRight\n}) => {\n  _s();\n  const [touchStart, setTouchStart] = useState({\n    x: 0,\n    time: 0\n  });\n  const [touchEnd, setTouchEnd] = useState({\n    x: 0,\n    time: 0\n  });\n  const [isSwiping, setIsSwiping] = useState(false);\n  const handleTouchStart = useCallback(e => {\n    setTouchStart({\n      x: e.touches[0].clientX,\n      time: Date.now()\n    });\n    setIsSwiping(true);\n  }, []);\n  const handleTouchMove = useCallback(e => {\n    if (!isSwiping) return;\n    setTouchEnd({\n      x: e.touches[0].clientX,\n      time: Date.now()\n    });\n  }, [isSwiping]);\n  const handleTouchEnd = useCallback(() => {\n    if (!isSwiping) return;\n    const distance = touchStart.x - touchEnd.x;\n    const time = touchEnd.time - touchStart.time;\n    const velocity = Math.abs(distance / time);\n    if (time <= TIME_THRESHOLD && velocity >= VELOCITY_THRESHOLD) {\n      if (distance > DISTANCE_THRESHOLD) {\n        onSwipeLeft === null || onSwipeLeft === void 0 ? void 0 : onSwipeLeft();\n      } else if (distance < -DISTANCE_THRESHOLD) {\n        onSwipeRight === null || onSwipeRight === void 0 ? void 0 : onSwipeRight();\n      }\n    }\n    setIsSwiping(false);\n    setTouchStart({\n      x: 0,\n      time: 0\n    });\n    setTouchEnd({\n      x: 0,\n      time: 0\n    });\n  }, [isSwiping, touchStart, touchEnd, onSwipeLeft, onSwipeRight]);\n  return {\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd,\n    isSwiping\n  };\n};\n_s(useSwipeGesture, \"MPYKTRa8g2dWAqmZDgFvGVry2tQ=\");","map":{"version":3,"names":["useState","useCallback","VELOCITY_THRESHOLD","DISTANCE_THRESHOLD","TIME_THRESHOLD","useSwipeGesture","onSwipeLeft","onSwipeRight","_s","touchStart","setTouchStart","x","time","touchEnd","setTouchEnd","isSwiping","setIsSwiping","handleTouchStart","e","touches","clientX","Date","now","handleTouchMove","handleTouchEnd","distance","velocity","Math","abs"],"sources":["C:/Users/iLogic/Desktop/sneakeralot_v_0.2/client/src/components/home/Hero/hooks/useSwipeGesture.js"],"sourcesContent":["import { useState, useCallback } from 'react';\r\n\r\nconst VELOCITY_THRESHOLD = 0.5; // Minimum velocity to trigger swipe\r\nconst DISTANCE_THRESHOLD = 50; // Minimum distance to trigger swipe\r\nconst TIME_THRESHOLD = 300; // Maximum time for a swipe gesture\r\n\r\nexport const useSwipeGesture = ({ onSwipeLeft, onSwipeRight }) => {\r\n  const [touchStart, setTouchStart] = useState({ x: 0, time: 0 });\r\n  const [touchEnd, setTouchEnd] = useState({ x: 0, time: 0 });\r\n  const [isSwiping, setIsSwiping] = useState(false);\r\n\r\n  const handleTouchStart = useCallback((e) => {\r\n    setTouchStart({\r\n      x: e.touches[0].clientX,\r\n      time: Date.now()\r\n    });\r\n    setIsSwiping(true);\r\n  }, []);\r\n\r\n  const handleTouchMove = useCallback((e) => {\r\n    if (!isSwiping) return;\r\n\r\n    setTouchEnd({\r\n      x: e.touches[0].clientX,\r\n      time: Date.now()\r\n    });\r\n  }, [isSwiping]);\r\n\r\n  const handleTouchEnd = useCallback(() => {\r\n    if (!isSwiping) return;\r\n\r\n    const distance = touchStart.x - touchEnd.x;\r\n    const time = touchEnd.time - touchStart.time;\r\n    const velocity = Math.abs(distance / time);\r\n\r\n    if (time <= TIME_THRESHOLD && velocity >= VELOCITY_THRESHOLD) {\r\n      if (distance > DISTANCE_THRESHOLD) {\r\n        onSwipeLeft?.();\r\n      } else if (distance < -DISTANCE_THRESHOLD) {\r\n        onSwipeRight?.();\r\n      }\r\n    }\r\n\r\n    setIsSwiping(false);\r\n    setTouchStart({ x: 0, time: 0 });\r\n    setTouchEnd({ x: 0, time: 0 });\r\n  }, [isSwiping, touchStart, touchEnd, onSwipeLeft, onSwipeRight]);\r\n\r\n  return {\r\n    handleTouchStart,\r\n    handleTouchMove,\r\n    handleTouchEnd,\r\n    isSwiping\r\n  };\r\n}; "],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAE7C,MAAMC,kBAAkB,GAAG,GAAG,CAAC,CAAC;AAChC,MAAMC,kBAAkB,GAAG,EAAE,CAAC,CAAC;AAC/B,MAAMC,cAAc,GAAG,GAAG,CAAC,CAAC;;AAE5B,OAAO,MAAMC,eAAe,GAAGA,CAAC;EAAEC,WAAW;EAAEC;AAAa,CAAC,KAAK;EAAAC,EAAA;EAChE,MAAM,CAACC,UAAU,EAAEC,aAAa,CAAC,GAAGV,QAAQ,CAAC;IAAEW,CAAC,EAAE,CAAC;IAAEC,IAAI,EAAE;EAAE,CAAC,CAAC;EAC/D,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGd,QAAQ,CAAC;IAAEW,CAAC,EAAE,CAAC;IAAEC,IAAI,EAAE;EAAE,CAAC,CAAC;EAC3D,MAAM,CAACG,SAAS,EAAEC,YAAY,CAAC,GAAGhB,QAAQ,CAAC,KAAK,CAAC;EAEjD,MAAMiB,gBAAgB,GAAGhB,WAAW,CAAEiB,CAAC,IAAK;IAC1CR,aAAa,CAAC;MACZC,CAAC,EAAEO,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO;MACvBR,IAAI,EAAES,IAAI,CAACC,GAAG,CAAC;IACjB,CAAC,CAAC;IACFN,YAAY,CAAC,IAAI,CAAC;EACpB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMO,eAAe,GAAGtB,WAAW,CAAEiB,CAAC,IAAK;IACzC,IAAI,CAACH,SAAS,EAAE;IAEhBD,WAAW,CAAC;MACVH,CAAC,EAAEO,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC,CAACC,OAAO;MACvBR,IAAI,EAAES,IAAI,CAACC,GAAG,CAAC;IACjB,CAAC,CAAC;EACJ,CAAC,EAAE,CAACP,SAAS,CAAC,CAAC;EAEf,MAAMS,cAAc,GAAGvB,WAAW,CAAC,MAAM;IACvC,IAAI,CAACc,SAAS,EAAE;IAEhB,MAAMU,QAAQ,GAAGhB,UAAU,CAACE,CAAC,GAAGE,QAAQ,CAACF,CAAC;IAC1C,MAAMC,IAAI,GAAGC,QAAQ,CAACD,IAAI,GAAGH,UAAU,CAACG,IAAI;IAC5C,MAAMc,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAACH,QAAQ,GAAGb,IAAI,CAAC;IAE1C,IAAIA,IAAI,IAAIR,cAAc,IAAIsB,QAAQ,IAAIxB,kBAAkB,EAAE;MAC5D,IAAIuB,QAAQ,GAAGtB,kBAAkB,EAAE;QACjCG,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAG,CAAC;MACjB,CAAC,MAAM,IAAImB,QAAQ,GAAG,CAACtB,kBAAkB,EAAE;QACzCI,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAG,CAAC;MAClB;IACF;IAEAS,YAAY,CAAC,KAAK,CAAC;IACnBN,aAAa,CAAC;MAAEC,CAAC,EAAE,CAAC;MAAEC,IAAI,EAAE;IAAE,CAAC,CAAC;IAChCE,WAAW,CAAC;MAAEH,CAAC,EAAE,CAAC;MAAEC,IAAI,EAAE;IAAE,CAAC,CAAC;EAChC,CAAC,EAAE,CAACG,SAAS,EAAEN,UAAU,EAAEI,QAAQ,EAAEP,WAAW,EAAEC,YAAY,CAAC,CAAC;EAEhE,OAAO;IACLU,gBAAgB;IAChBM,eAAe;IACfC,cAAc;IACdT;EACF,CAAC;AACH,CAAC;AAACP,EAAA,CAhDWH,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}