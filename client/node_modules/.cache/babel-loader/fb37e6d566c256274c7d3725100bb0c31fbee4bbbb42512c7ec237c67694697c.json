{"ast":null,"code":"// Constants\nconst SEARCH_HISTORY_KEY = 'searchHistory';\nconst MAX_HISTORY_ITEMS = 10;\n\n// Mock data for trending searches (replace with API call later)\nconst mockTrendingSearches = [{\n  id: 1,\n  text: 'Nike Dunk Low',\n  searches: 15234,\n  trending: true\n}, {\n  id: 2,\n  text: 'Jordan 4 Retro',\n  searches: 12456,\n  trending: true\n}, {\n  id: 3,\n  text: 'Yeezy Slides',\n  searches: 10789,\n  trending: true\n}, {\n  id: 4,\n  text: 'New Balance 550',\n  searches: 9876,\n  trending: true\n}, {\n  id: 5,\n  text: 'Air Force 1',\n  searches: 8765,\n  trending: false\n}];\n\n// Mock data for personalized suggestions (replace with API call later)\nconst mockPersonalizedSuggestions = [{\n  id: 1,\n  text: 'Nike Air Max',\n  reason: 'Based on your recent purchase'\n}, {\n  id: 2,\n  text: 'Jordan 1 Low',\n  reason: 'Similar to items you viewed'\n}, {\n  id: 3,\n  text: 'Adidas Ultra Boost',\n  reason: 'You might like this'\n}];\n\n// Levenshtein distance for spell checking\nconst getLevenshteinDistance = (str1, str2) => {\n  const track = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));\n  for (let i = 0; i <= str1.length; i++) track[0][i] = i;\n  for (let j = 0; j <= str2.length; j++) track[j][0] = j;\n  for (let j = 1; j <= str2.length; j++) {\n    for (let i = 1; i <= str1.length; i++) {\n      const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\n      track[j][i] = Math.min(track[j][i - 1] + 1, track[j - 1][i] + 1, track[j - 1][i - 1] + indicator);\n    }\n  }\n  return track[str2.length][str1.length];\n};\nexport const searchService = {\n  // Get search history\n  getSearchHistory: () => {\n    try {\n      const history = localStorage.getItem(SEARCH_HISTORY_KEY);\n      return history ? JSON.parse(history) : [];\n    } catch (error) {\n      console.error('Error getting search history:', error);\n      return [];\n    }\n  },\n  // Add search to history\n  addToHistory: searchTerm => {\n    try {\n      const history = searchService.getSearchHistory();\n      const timestamp = new Date().toISOString();\n\n      // Remove existing entry if present\n      const filteredHistory = history.filter(item => item.text !== searchTerm);\n\n      // Add new entry at the beginning\n      const newHistory = [{\n        text: searchTerm,\n        timestamp\n      }, ...filteredHistory].slice(0, MAX_HISTORY_ITEMS);\n      localStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(newHistory));\n      return newHistory;\n    } catch (error) {\n      console.error('Error adding to search history:', error);\n      return [];\n    }\n  },\n  // Clear search history\n  clearHistory: () => {\n    try {\n      localStorage.removeItem(SEARCH_HISTORY_KEY);\n      return true;\n    } catch (error) {\n      console.error('Error clearing search history:', error);\n      return false;\n    }\n  },\n  // Get trending searches\n  getTrendingSearches: async () => {\n    // Simulate API call\n    return new Promise(resolve => {\n      setTimeout(() => resolve(mockTrendingSearches), 300);\n    });\n  },\n  // Get personalized suggestions\n  getPersonalizedSuggestions: async () => {\n    // Simulate API call\n    return new Promise(resolve => {\n      setTimeout(() => resolve(mockPersonalizedSuggestions), 300);\n    });\n  },\n  // Get spell suggestions\n  getSpellSuggestions: (query, dictionary) => {\n    if (!query || query.length < 2) return [];\n\n    // Dictionary would be a list of valid search terms\n    // For now, we'll use a mock dictionary\n    const mockDictionary = ['nike', 'adidas', 'jordan', 'yeezy', 'boost', 'air max', 'dunk', 'ultra boost', 'air force', 'new balance', 'reebok', 'puma', 'converse', 'vans', 'asics', 'saucony'];\n    const suggestions = mockDictionary.map(word => ({\n      word,\n      distance: getLevenshteinDistance(query.toLowerCase(), word.toLowerCase())\n    })).filter(({\n      distance\n    }) => distance > 0 && distance <= 3).sort((a, b) => a.distance - b.distance).slice(0, 3).map(({\n      word\n    }) => word);\n    return suggestions;\n  },\n  // Format relative time\n  formatRelativeTime: timestamp => {\n    const now = new Date();\n    const date = new Date(timestamp);\n    const diff = now - date;\n    const seconds = Math.floor(diff / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    if (days > 0) {\n      return `${days}d ago`;\n    } else if (hours > 0) {\n      return `${hours}h ago`;\n    } else if (minutes > 0) {\n      return `${minutes}m ago`;\n    } else {\n      return 'Just now';\n    }\n  }\n};","map":{"version":3,"names":["SEARCH_HISTORY_KEY","MAX_HISTORY_ITEMS","mockTrendingSearches","id","text","searches","trending","mockPersonalizedSuggestions","reason","getLevenshteinDistance","str1","str2","track","Array","length","fill","map","i","j","indicator","Math","min","searchService","getSearchHistory","history","localStorage","getItem","JSON","parse","error","console","addToHistory","searchTerm","timestamp","Date","toISOString","filteredHistory","filter","item","newHistory","slice","setItem","stringify","clearHistory","removeItem","getTrendingSearches","Promise","resolve","setTimeout","getPersonalizedSuggestions","getSpellSuggestions","query","dictionary","mockDictionary","suggestions","word","distance","toLowerCase","sort","a","b","formatRelativeTime","now","date","diff","seconds","floor","minutes","hours","days"],"sources":["C:/Users/iLogic/Desktop/sneakeralot_v_0.2/client/src/services/searchService.js"],"sourcesContent":["// Constants\r\nconst SEARCH_HISTORY_KEY = 'searchHistory';\r\nconst MAX_HISTORY_ITEMS = 10;\r\n\r\n// Mock data for trending searches (replace with API call later)\r\nconst mockTrendingSearches = [\r\n  { id: 1, text: 'Nike Dunk Low', searches: 15234, trending: true },\r\n  { id: 2, text: 'Jordan 4 Retro', searches: 12456, trending: true },\r\n  { id: 3, text: 'Yeezy Slides', searches: 10789, trending: true },\r\n  { id: 4, text: 'New Balance 550', searches: 9876, trending: true },\r\n  { id: 5, text: 'Air Force 1', searches: 8765, trending: false }\r\n];\r\n\r\n// Mock data for personalized suggestions (replace with API call later)\r\nconst mockPersonalizedSuggestions = [\r\n  { id: 1, text: 'Nike Air Max', reason: 'Based on your recent purchase' },\r\n  { id: 2, text: 'Jordan 1 Low', reason: 'Similar to items you viewed' },\r\n  { id: 3, text: 'Adidas Ultra Boost', reason: 'You might like this' }\r\n];\r\n\r\n// Levenshtein distance for spell checking\r\nconst getLevenshteinDistance = (str1, str2) => {\r\n  const track = Array(str2.length + 1).fill(null).map(() =>\r\n    Array(str1.length + 1).fill(null));\r\n\r\n  for (let i = 0; i <= str1.length; i++) track[0][i] = i;\r\n  for (let j = 0; j <= str2.length; j++) track[j][0] = j;\r\n\r\n  for (let j = 1; j <= str2.length; j++) {\r\n    for (let i = 1; i <= str1.length; i++) {\r\n      const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\r\n      track[j][i] = Math.min(\r\n        track[j][i - 1] + 1,\r\n        track[j - 1][i] + 1,\r\n        track[j - 1][i - 1] + indicator\r\n      );\r\n    }\r\n  }\r\n\r\n  return track[str2.length][str1.length];\r\n};\r\n\r\nexport const searchService = {\r\n  // Get search history\r\n  getSearchHistory: () => {\r\n    try {\r\n      const history = localStorage.getItem(SEARCH_HISTORY_KEY);\r\n      return history ? JSON.parse(history) : [];\r\n    } catch (error) {\r\n      console.error('Error getting search history:', error);\r\n      return [];\r\n    }\r\n  },\r\n\r\n  // Add search to history\r\n  addToHistory: (searchTerm) => {\r\n    try {\r\n      const history = searchService.getSearchHistory();\r\n      const timestamp = new Date().toISOString();\r\n      \r\n      // Remove existing entry if present\r\n      const filteredHistory = history.filter(item => item.text !== searchTerm);\r\n      \r\n      // Add new entry at the beginning\r\n      const newHistory = [\r\n        { text: searchTerm, timestamp },\r\n        ...filteredHistory\r\n      ].slice(0, MAX_HISTORY_ITEMS);\r\n\r\n      localStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(newHistory));\r\n      return newHistory;\r\n    } catch (error) {\r\n      console.error('Error adding to search history:', error);\r\n      return [];\r\n    }\r\n  },\r\n\r\n  // Clear search history\r\n  clearHistory: () => {\r\n    try {\r\n      localStorage.removeItem(SEARCH_HISTORY_KEY);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error clearing search history:', error);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  // Get trending searches\r\n  getTrendingSearches: async () => {\r\n    // Simulate API call\r\n    return new Promise(resolve => {\r\n      setTimeout(() => resolve(mockTrendingSearches), 300);\r\n    });\r\n  },\r\n\r\n  // Get personalized suggestions\r\n  getPersonalizedSuggestions: async () => {\r\n    // Simulate API call\r\n    return new Promise(resolve => {\r\n      setTimeout(() => resolve(mockPersonalizedSuggestions), 300);\r\n    });\r\n  },\r\n\r\n  // Get spell suggestions\r\n  getSpellSuggestions: (query, dictionary) => {\r\n    if (!query || query.length < 2) return [];\r\n\r\n    // Dictionary would be a list of valid search terms\r\n    // For now, we'll use a mock dictionary\r\n    const mockDictionary = [\r\n      'nike', 'adidas', 'jordan', 'yeezy', 'boost', 'air max', 'dunk',\r\n      'ultra boost', 'air force', 'new balance', 'reebok', 'puma',\r\n      'converse', 'vans', 'asics', 'saucony'\r\n    ];\r\n\r\n    const suggestions = mockDictionary\r\n      .map(word => ({\r\n        word,\r\n        distance: getLevenshteinDistance(query.toLowerCase(), word.toLowerCase())\r\n      }))\r\n      .filter(({ distance }) => distance > 0 && distance <= 3)\r\n      .sort((a, b) => a.distance - b.distance)\r\n      .slice(0, 3)\r\n      .map(({ word }) => word);\r\n\r\n    return suggestions;\r\n  },\r\n\r\n  // Format relative time\r\n  formatRelativeTime: (timestamp) => {\r\n    const now = new Date();\r\n    const date = new Date(timestamp);\r\n    const diff = now - date;\r\n    const seconds = Math.floor(diff / 1000);\r\n    const minutes = Math.floor(seconds / 60);\r\n    const hours = Math.floor(minutes / 60);\r\n    const days = Math.floor(hours / 24);\r\n\r\n    if (days > 0) {\r\n      return `${days}d ago`;\r\n    } else if (hours > 0) {\r\n      return `${hours}h ago`;\r\n    } else if (minutes > 0) {\r\n      return `${minutes}m ago`;\r\n    } else {\r\n      return 'Just now';\r\n    }\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}